> 🚨 Note: This log may contain personal information such as the contents of your files or terminal output. Please review the contents carefully before sharing.
# panel/unknown - be5ea636

## Metadata
~~~
requestType      : ChatCompletions
model            : claude-opus-4
maxPromptTokens  : 68001
maxResponseTokens: 16000
location         : 1
postOptions      : {"temperature":0.1,"top_p":1,"max_tokens":16000,"n":1,"stream":true}
intent           : undefined
startTime        : 2025-08-26T19:51:03.537Z
endTime          : 2025-08-26T19:51:33.345Z
duration         : 29808ms
ourRequestId     : 8475deab-dd97-4d6e-b4a4-940f71afc64c
requestId        : 8475deab-dd97-4d6e-b4a4-940f71afc64c
serverRequestId  : 8475deab-dd97-4d6e-b4a4-940f71afc64c
timeToFirstToken : 2528ms
usage            : {"completion_tokens":1097,"prompt_tokens":25889,"prompt_tokens_details":{"cached_tokens":0},"total_tokens":26986}
~~~
## Request Messages
### System
~~~md
You are an AI programming assistant.
When asked for your name, you must respond with "GitHub Copilot".
Follow the user's requirements carefully & to the letter.
Follow Microsoft content policies.
Avoid content that violates copyrights.
If you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with "Sorry, I can't assist with that."
Keep your answers short and impersonal.
You can answer general programming questions and perform the following tasks: 
* Ask a question about the files in your current workspace
* Explain how the code in your active editor works
* Make changes to existing code
* Review the selected code in your active editor
* Generate unit tests for the selected code
* Propose a fix for the problems in the selected code
* Scaffold code for a new file or project in a workspace
* Create a new Jupyter Notebook
* Ask questions about VS Code
* Generate query parameters for workspace search
* Ask how to do something in the terminal
* Explain what just happened in the terminal
* Propose a fix for the problems in the selected code
* Explain how the code in your active editor works
* Review the selected code in your active editor
* Generate unit tests for the selected code
* Make changes to existing code
You use the Claude Opus 4 large language model.
The user has the following folder open: c:\Users\josel\MATLAB\Projects\ClampedPinnedRodSolver.
The current date is August 26, 2025.
Use Markdown formatting in your answers.
When suggesting code changes or new content, use Markdown code blocks.
To start a code block, use 4 backticks.
After the backticks, add the programming language name.
If the code modifies an existing file or should be placed at a specific location, add a line comment with 'filepath:' and the file path.
If you want the user to decide where to place the code, do not add the file path comment.
In the code block, use a line comment with '...existing code...' to indicate code that is already present in the file.
````languageId
// filepath: c:\path\to\file
// ...existing code...
{ changed code }
// ...existing code...
{ changed code }
// ...existing code...
````For code blocks use four backticks to start and end.
Avoid wrapping the whole response in triple backticks.
The user works in an IDE called Visual Studio Code which has a concept for editors with open files, integrated unit test support, an output pane that shows the output of running the code as well as an integrated terminal.
The user is working on a Windows machine. Please respond with system specific commands if applicable.
The active document is the source code the user is looking at right now.
You can only give one reply for each conversation turn.
~~~

### User
~~~md
Review the functionallity of clamp_fixed_rod_solver.jl
~~~

### Assistant
~~~md
## Review of `clamp_fixed_rod_solver.jl` Functionality

### Overview
This Julia solver interfaces with MATLAB to generate learning datasets for clamped-pinned rod configurations. It rotates the clamped end through 360° while maintaining a fixed pinned end position, solving inverse kinematics at each step.

### Key Functionality

#### 1. **Configuration Management**
- Accepts `ClampedRodConfig` parameter or uses defaults
- Supports customizable rotation parameters (angle, steps, save points)
- Automatically formats file naming conventions (e.g., `xp=0.2` → `X02`)

#### 2. **MATLAB Integration**
- Manages MATLAB engine lifecycle with error recovery
- Sets up proper paths for MATLAB code execution
- Handles variable transfer between Julia and MATLAB environments
- Implements memory management to prevent crashes during long computations

#### 3. **Data Generation Algorithm**
```julia
# For each rotation angle:
1. Transform target coordinates to local frame
2. Solve inverse kinematics using IK_fsolve
3. Transform results back to global frame
4. Store configuration data (11 parameters + shape data)
```

#### 4. **Output Generation**
- **Dataset**: `LearnigData_Rod_Clamp_Pin_Rot_[XP]_[YP]_[N]sols_mode[M].mat`
- **Visualizations**: 9 different plots saved as PNG/FIG
  - Initial rod configuration plots
  - Motion animation
  - Phase plots
  - Parameter evolution plots

### Strengths

1. **Robust Error Handling**
   - Multiple retry attempts for MATLAB initialization
   - Graceful handling of early termination
   - File existence validation before execution

2. **Memory Management**
   - Periodic cleanup during computation loops
   - Configurable save points to prevent data loss

3. **Comprehensive Documentation**
   - Detailed docstring with examples
   - Clear parameter descriptions
   - Usage examples for different scenarios

4. **Flexible Configuration**
   - Supports negative xp/yp values
   - Customizable rotation parameters
   - Multiple solution modes

### Areas for Improvement

1. **Code Organization**
   - The function is very long (~1500 lines) - consider breaking into smaller functions
   - MATLAB code embedded as strings makes maintenance difficult

2. **Error Messages**
   - Some error paths could provide more specific guidance
   - Dataset retrieval failures could be more informative

3. **Performance**
   - No parallel processing utilized
   - Could benefit from progress bars for long computations

4. **Testing**
   - No unit tests included
   - Could benefit from validation against known solutions

### Technical Details

#### Input Parameters (via config)
- Rod geometry: `L`, `EI`, `N`
- Target position: `xp`, `yp`
- Mode parameters: `mode`, `sol_number`
- Rotation: `rotation_angle`, `angular_steps`, `save_at_step`

#### Output Structure
Each trajectory contains:
```
1-3:   Clamped end position & orientation (px₀, py₀, θ₀)
4:     Buckling mode number
5-6:   Pinned end position (px_end, py_end)
7-9:   Initial forces (M₀, Fx₀, Fy₀)
10-11: Force magnitude & direction
12+:   Rod shape arrays (px, py, moments, angles)
```

### Usage Recommendations

1. **Before Running**:
   - Ensure MATLAB is installed with valid license
   - Verify required rod data files exist
   - Check available disk space for outputs

2. **Parameter Selection**:
   - Start with small `angular_steps` for testing
   - Use `save_at_step` to protect against crashes
   - Choose `xp` values with existing rod data

3. **Troubleshooting**:
   - If MATLAB fails: Run `matlab -regserver` as admin
   - If solver fails: Try smaller `xp` values
   - If memory issues: Reduce `angular_steps`

### Conclusion

This is a well-structured solver that effectively bridges Julia and MATLAB for complex mechanical simulations. While it could benefit from modularization and enhanced error handling, it provides robust functionality for generating machine learning datasets from rod mechanics simulations.
~~~

### User
~~~md
<attachments>
<attachment id="file:clamp_fixed_rod_solver.jl">
User's active file:
````julia
# filepath: c:\Users\josel\MATLAB\Projects\ClampedPinnedRodSolver\src\solvers\clamp_fixed_rod_solver.jl
# ---------------------------------------------------------------------------
# Clamp Fixed Rod Solver
# 
# Generates datasets by rotating the clamped end of the rod and solving
# for each rotation angle.
# 
# Can be run standalone or as part of the EllipticalRodSolver module
# ---------------------------------------------------------------------------

# Setup for standalone usage (when run directly)
if !@isdefined(ClampedRodConfig)
    include("../utils/project_utils.jl")
    include("../utils/config.jl")
end

# Import required packages
using JLD2
using Dates

# Main solver function starts here
using Statistics

# -----------------------------------------------------------------------------
# Julia function to call MATLAB rotate clamp-fixed solver, AA_Rotate_Clamp_FixedTip.m, and compare results
"""
    clamp_fixed_rod_solver(config::Union{ClampedRodConfig, Nothing} = nothing)

Generates learning data for clamped-pinned rod configurations by rotating the clamp through 360°.

This function interfaces with MATLAB to generate a dataset of rod configurations by rotating 
the clamped end through a complete 360° rotation while maintaining the pinned end at a fixed 
position. The solver uses an existing rod solution as initial configuration and incrementally 
rotates the clamp, solving inverse kinematics at each step to generate training data for 
machine learning applications.

# Arguments
- `config::Union{ClampedRodConfig, Nothing} = nothing`: Rod configuration parameters. 
  If `nothing`, uses default configuration from `get_default_config()`.

# Algorithm Steps
1. **Load Initial Configuration**: Uses parametric rod data file as starting point
2. **Setup Rotation Parameters**: Defines 360° rotation divided into configurable steps
3. **Incremental Solving**: For each rotation angle:
   - Transform target coordinates to local frame
   - Solve inverse kinematics using `IK_fsolve`
   - Transform results back to global frame
   - Store configuration data
4. **Visualization**: Generate real-time plots showing rod motion and analysis
5. **Data Export**: Save complete dataset as learning data for ML training

# Configuration Parameters
All parameters are loaded from the config struct, including:
- `rotation_angle`: Total rotation angle (default 360°)
- `angular_steps`: Number of angular steps (default 72 for 5° increments)
- `save_at_step`: Iteration to save intermediate data (default 72, loop continues to completion)
- `sol_number`: Solution number from initial rod data (from config.sol_number)
- `rod_mode`: Rod buckling mode number (from config.mode)
- `xp_suffix`: Target position identifier (automatically generated from config.xp)

# Returns
- `Bool`: `true` if data generation completed successfully, `false` if errors occurred

# Generated Data Structure
Each trajectory contains 11 base parameters plus rod shape data:
1. **Position data**: Clamped end position (px₀, py₀)
2. **Orientation**: Clamped end angle (θ₀ + rotation)
3. **Mode**: Buckling mode number
4. **Target**: Pinned end position (px_end, py_end)
5. **Forces**: Initial moment and forces (M₀, Fx₀, Fy₀)
6. **Magnitude**: Resultant force magnitude
7. **Direction**: Force direction angle
8. **Shape**: Complete rod geometry (px, py arrays)
9. **Curvature**: Moment distribution along rod
10. **Slope**: Angle distribution along rod

# Output Files
Generated in timestamped folders under `dataset/MATLAB code/Learning_Data_ClampedPinned_Rod_IK/`:
- **Learning Data**: `LearnigData_Rod_Clamp_Pin_Rot_[XP]_[YP]_[N]sols_mode[M].mat`
- **Figures**: Motion visualization, phase plots, and analysis charts (PNG/FIG)
- **Reference Comparison**: Statistical validation against existing reference data

# Examples
```julia
# Using default configuration
success = clamp_fixed_rod_solver()

# Using custom configuration
config = create_config(xp = 0.5, yp = 0.0, mode = 2.0)
success = clamp_fixed_rod_solver(config)

# For different rod geometries
config = create_config(L = 2.0, EI = 0.5, N = 100)
success = clamp_fixed_rod_solver(config)

# With different solution numbers
config = create_config(sol_number = 2, mode = 2.0)  # Use solution 2
success = clamp_fixed_rod_solver(config)

# With different target positions (affects xp_suffix automatically)
config = create_config(xp = 0.2, mode = 2.0)  # Will use "X02" suffix
success = clamp_fixed_rod_solver(config)

config = create_config(xp = 0.8, mode = 3.0)  # Will use "X08" suffix
success = clamp_fixed_rod_solver(config)

# With different rotation configurations
config = create_config(rotation_angle = 180.0, angular_steps = 36)
success = clamp_fixed_rod_solver(config)

# High resolution rotation
config = create_config(angular_steps = 360, save_at_step = 350)
success = clamp_fixed_rod_solver(config)

# With tilted initial clamped end
config = create_config(theta = π/4, xp = 0.3, yp = 0.1)
success = clamp_fixed_rod_solver(config)
```

# Application
Primarily used for generating training datasets for:
- **Neural Networks**: Learning inverse kinematics mappings
- **Machine Learning**: Pattern recognition in flexible rod behavior
- **Control Systems**: Developing model-based controllers
- **Robotics**: Soft/continuum robot control algorithms

# Notes
- Requires existing rod solution file matching the parametric naming convention
- MATLAB engine and valid license required
- Solver may terminate early if numerical convergence fails
- Configurable save point prevents data loss on early termination
- Reference comparison validates against known good solutions
- Real-time visualization shows rod motion during data generation

# Performance
- Typical execution: 2-5 minutes for 72 trajectories
- Memory usage: Moderate (stores complete rod shapes)
- Output size: ~1-10 MB depending on rod discretization

# References
Based on work from University of the Basque Country UPV/EHU (Oscar Altuzarra, 2025)
"""
function clamp_fixed_rod_solver(config::Union{ClampedRodConfig, Nothing} = nothing)
    try
        # Load configuration parameters
        if config === nothing
            config = get_default_config()
            println("✓ Using default configuration")
        else
            println("✓ Using provided configuration")
        end
        
        # Extract base rod parameters from config
        xp = config.xp                 # X coordinate of end-tip [m]
        yp = config.yp                 # Y coordinate of end-tip [m]
        rod_mode = config.mode             # Buckling Mode in Elliptic Integrals approach
        
        # Extract rotation parameters from config
        rotation_angle_rad = config.rotation_angle * pi / 180.0  # Total rotation angle [rad] (from config)
        Ntheta = Float64(config.angular_steps)     # Number of angular steps (from config)
        last_solved_trajectory = config.save_at_step  # Premature save trajectory (from config)
        
        # Rod configuration parameters (derived from config)
        sol_number = config.sol_number     # Solution number from config
        
        # Format xp suffix for file naming (e.g., 0.2 -> X02, 0.5 -> X05, -0.2 -> XN02)
        xp_scaled = abs(round(xp * 10))
        if xp >= 0
            if xp_scaled < 10
                xp_suffix = "X0$(Int(xp_scaled))"
            else
                xp_suffix = "X$(Int(xp_scaled))"
            end
        else
            # Handle negative xp values with 'XN' prefix  
            if xp_scaled < 10
                xp_suffix = "XN0$(Int(xp_scaled))"
            else
                xp_suffix = "XN$(Int(xp_scaled))"
            end
        end
        
        # Format yp suffix for file naming (e.g., 0.0 -> Y00, 0.5 -> Y05, -0.3 -> YN03)
        yp_scaled = abs(round(yp * 10))
        if yp >= 0
            if yp_scaled < 10
                yp_suffix = "Y0$(Int(yp_scaled))"
            else
                yp_suffix = "Y$(Int(yp_scaled))"
            end
        else
            # Handle negative yp values with 'YN' prefix  
            if yp_scaled < 10
                yp_suffix = "YN0$(Int(yp_scaled))"
            else
                yp_suffix = "YN$(Int(yp_scaled))"
            end
        end

        # Print configuration using the utility function
        println("\n✓ Input parameters loaded from configuration")
        print_config(config)

        # Detect the project root using the utility function
        project_root = find_project_root()
        println("✓ Project root detected: $project_root \n")
        
        # Set up MATLAB paths using detected project root
        println("✓ Setting MATLAB paths from: $project_root")
        
        # Convert Windows backslashes to forward slashes for MATLAB compatibility
        matlab_project_root = replace(project_root, '\\' => '/')
        println("✓ Normalized path for MATLAB: $matlab_project_root\n")
        
        # Generate single timestamp for consistent folder naming across all MATLAB blocks
        timestamp_str = Dates.format(now(), "yyyy-mm-dd_HH-MM-SS")
        println("✓ Generated timestamp for figures: $timestamp_str")
        
        # MATLAB engine error handling and initialization
        println("🔄 Ensuring clean MATLAB environment...")
        
        # Instead of restarting, clean the existing session
        try
            println("🧹 Cleaning existing MATLAB session variables...")
            # Clear variables and figures but keep the session alive
            mat"""
            close all;  % Close all figures
            clearvars;  % Clear variables but keep functions
            clc;        % Clear command window
            fprintf('✓ MATLAB session cleaned (variables cleared, session kept alive)\\n');
            """
            
            println("✓ MATLAB session cleaned successfully")
            sleep(2)  # Brief pause
            
        catch e
            println("⚠️ MATLAB cleanup warning (trying to continue): $(e)")
            # If cleaning fails, the session might already be clean or corrupted
            # Let's try a more aggressive cleanup
            try
                println("🔄 Attempting aggressive MATLAB cleanup...")
                mat"""
                close all force;
                clear all;
                fprintf('✓ Aggressive MATLAB cleanup completed\\n');
                """
                println("✓ Aggressive cleanup successful")
            catch e2
                println("⚠️ Both cleanup attempts failed: $(e2)")
                println("🔄 Continuing with existing session state...")
            end
        end
        
        println("🔄 Initializing fresh MATLAB engine...")
        
        # Try to initialize MATLAB engine with enhanced error recovery
        matlab_init_success = false
        init_attempts = 0
        max_init_attempts = 5  # Increased attempts after crash
        
        while !matlab_init_success && init_attempts < max_init_attempts
            init_attempts += 1
            try
                println("Attempt $init_attempts/$max_init_attempts: Testing MATLAB engine...")
                
                # Test MATLAB engine with a simple command
                mat"""
                % Basic MATLAB initialization and engine test
                close all ; % clear ; clc;  % Commented out 'clear' to preserve variables between blocks
                fprintf('MATLAB engine initialized successfully\\n');
                test_var = 1;  % Simple test to verify engine is working
                """
                
                matlab_init_success = true
                println("✓ MATLAB engine initialized successfully")
                
            catch e
                println("⚠️  MATLAB engine initialization attempt $init_attempts failed: $(e)")
                
                if init_attempts < max_init_attempts
                    println("🔄 Retrying MATLAB engine initialization...")
                    sleep(2)  # Wait 2 seconds before retry
                else
                    println("❌ MATLAB engine initialization failed after $max_init_attempts attempts")
                    println("💡 Solutions:")
                    println("1. Ensure MATLAB is installed and licensed")
                    println("2. Run 'matlab -regserver' in Command Prompt as Administrator")  
                    println("3. Restart Julia and try again")
                    println("4. Check if another MATLAB instance is running")
                    return false
                end
            end
        end
        
        # Main MATLAB execution with error handling
        println("🔄 Starting MATLAB solver execution...")
        
        try
            # Now send the project root path and timestamp to MATLAB
            @mput matlab_project_root timestamp_str sol_number xp_suffix yp_suffix xp yp rod_mode
            
            mat"""
            % MATLAB path setup with received project root and timestamp
            project_root = matlab_project_root;
        
        % Convert xp_suffix back to numerical value for comparison logic
        % xp_suffix format: "X02" -> xp = 0.2, "X05" -> xp = 0.5, etc.
        xp_num_str = xp_suffix(2:end);  % Remove 'X' prefix
        xp = str2double(xp_num_str) / 10;  % Convert back to decimal

        fprintf('Using project root: %s\\n', project_root);

        % Set up paths based on actual folder structure
        addpath(fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK'));
        addpath(fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', 'Rotate_Clamp'));
        addpath(fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', 'Rotate_Clamp', 'Functions'));
        addpath(fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', 'Rotate_Clamp', 'Rotated_Clamp'));
        
        % Set the main data folder path for file operations
        data_folder = fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', 'Rotate_Clamp', 'Rotated_Clamp');

        % Create timestamped folder for saving figures (using consistent timestamp)
        figures_base = fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', 'Rotate_Clamp', 'Rotated_Clamp', 'Figures');
        
        % Format xp value for folder naming (e.g., 0.2 -> X02, 0.5 -> X05, -0.2 -> XN02)
        xp_scaled = abs(round(xp * 10));
        if xp >= 0
            if xp_scaled < 10
                xp_str = sprintf('X0%d', xp_scaled);
            else
                xp_str = sprintf('X%d', xp_scaled);
            end
        else
            % Handle negative values
            if xp_scaled < 10
                xp_str = sprintf('XN0%d', xp_scaled);
            else
                xp_str = sprintf('XN%d', xp_scaled);
            end
        end
        
        % Format yp value for folder naming (e.g., 0.0 -> Y00, 0.5 -> Y05, -0.3 -> YN03)
        yp_scaled = round(abs(yp) * 10);
        if yp >= 0
            if yp_scaled < 10
                yp_str = sprintf('Y0%d', yp_scaled);
            else
                yp_str = sprintf('Y%d', yp_scaled);
            end
        else
            if yp_scaled < 10
                yp_str = sprintf('YN0%d', yp_scaled);
            else
                yp_str = sprintf('YN%d', yp_scaled);
            end
        end
        
        % Create folder name with timestamp, mode, xp and yp identifiers
        figures_folder_name = sprintf('%s_mode_%d_%s_%s', timestamp_str, rod_mode, xp_str, yp_str);
        figures_folder = fullfile(figures_base, figures_folder_name);
        
        if ~exist(figures_base, 'dir')
            mkdir(figures_base);
            fprintf('✓ Created figures base folder: %s\\n', figures_base);
        end
        if ~exist(figures_folder, 'dir')
            mkdir(figures_folder);
            fprintf('✓ Created figures folder: %s\\n', figures_folder);
        end

        % Display constructed paths for debugging
        fprintf('Project root: %s\\n', project_root);
        fprintf('Data folder: %s\\n', data_folder);
        fprintf('Figures will be saved to: %s\\n', figures_folder);

        % Verify directories exist
        base_dir = fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK');
        if exist(base_dir, 'dir') ~= 7
            error('MATLAB base directory not found at: %s', base_dir);
        end

        % Add paths and verify they exist
        if exist(fullfile(base_dir, 'Rotate_Clamp'), 'dir') == 7
            fprintf('✓ Added Rotate Clamp path to MATLAB\\n');
        end
        if exist(fullfile(base_dir, 'Rotate_Clamp', 'Functions'), 'dir') == 7
            fprintf('✓ Added Rotate Clamp Functions path to MATLAB\\n');
        end

        fprintf('\\n✓ MATLAB paths configured from project root\\n');
        fprintf('  Base: %s\\n', base_dir);
        fprintf('  Rotate Clamp: %s\\n', fullfile(base_dir, 'Rotate_Clamp'));
        fprintf('  Data folder: %s\\n', data_folder);

        % Verify MATLAB files exist
        if exist('AA_Rotate_Clamp_FixedTip.m', 'file') ~= 2
            error('MATLAB script AA_Rotate_Clamp_FixedTip.m not found in path');
        end
        if exist('IK_fsolve.m', 'file') ~= 2
            error('MATLAB function IK_fsolve.m not found in path');
        end
        """
        
        println("✓ MATLAB paths and functions verified")
        
        # Send parametric variables to MATLAB for file verification
        @mput sol_number xp_suffix yp_suffix rod_mode
        
        # Now verify the parametric rod data file exists
        mat"""
        % Check for parametric rod data file (now that variables are available)
        rod_check_filename = ['CLampedPinnedRod_sol_' num2str(sol_number) '_mode_' num2str(rod_mode) '_' xp_suffix '_' yp_suffix '.mat'];
        fprintf('Checking for rod data file: %s\\n', rod_check_filename);
        
        % Get current directory and search path
        current_dir = pwd;
        fprintf('Current directory: %s\\n', current_dir);
        
        % Check in the main data location
        possible_locations = {
            fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', 'Rotate_Clamp', 'Rotated_Clamp')
        };
        
        file_found = false;
        file_location = '';
        
        for i = 1:length(possible_locations)
            check_path = fullfile(possible_locations{i}, rod_check_filename);
            if exist(check_path, 'file') == 2
                file_found = true;
                file_location = possible_locations{i};
                fprintf('✓ Found rod data file in: %s\\n', file_location);
                break;
            end
        end
        
        if ~file_found
            error('MATLAB data file %s not found in any location', rod_check_filename);
        end
        """
        
        println("✓ Rod data file verified")
        
        
        # Matlab original code: AA_Rotate_Clamp_FixedTip.m
        mat"""
        % Notes(10/08/2025): added code lines
        % --> %load('CLampedPinnedRod_sol_1_mode_2_X02.mat') ;
        % --> %addpath('Functions') ; % Note: Paths are already configured properly in the earlier section
        % --> %save('LearnigData_Rod_Clamp_Pin_Rot_X02_72sol_mod2','DataSet') ;
        % --> % Save DataSet when Ntheta = last solved trajectory
        % --> typo error: font_size = 10 ; instead of fontsiz = 10 ;
        %
        % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %
        %           UNIVERSITY OF THE BASQUE COUNTRY UPV/EHU
        %
        %           Solution of the Inverse Position Problem of a
        %           Clamped Pinned Rod using Runge-Kutta integration from a home
        %           position as the Clamping is rotated
        %
        %                       8 April, 2025
        %
        %           Authors:
        %                       Oscar Altuzarra
        %           Contact:
        %                       oscar.altuzarra@ehu.es
        %           
        % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %
        %
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %% 
        % INITIALIZATION
        close all ; clear ; clc;
        %addpath('Functions') ;
        % Note: Paths are already configured properly in the earlier section
        """
        
        # Send parametric variables to MATLAB after clear statement
        @mput sol_number xp_suffix yp_suffix matlab_project_root timestamp_str rod_mode xp yp
        
        mat"""
        % Re-add paths after clear statement
        project_root = matlab_project_root;
        addpath(fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK'));
        addpath(fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', 'Rotate_Clamp'));
        addpath(fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', 'Rotate_Clamp', 'Rotated_Clamp'));

        % Recreate xp_str and yp_str variables after clear statement
        % Format xp value for folder naming (e.g., 0.2 -> X02, 0.5 -> X05, -0.2 -> XN02)
        xp_scaled = abs(round(xp * 10));
        if xp >= 0
            if xp_scaled < 10
                xp_str = sprintf('X0%d', xp_scaled);
            else
                xp_str = sprintf('X%d', xp_scaled);
            end
        else
            % Handle negative values
            if xp_scaled < 10
                xp_str = sprintf('XN0%d', xp_scaled);
            else
                xp_str = sprintf('XN%d', xp_scaled);
            end
        end
        
        % Format yp value for folder naming (e.g., 0.0 -> Y00, 0.5 -> Y05, -0.3 -> YN03)
        yp_scaled = round(abs(yp) * 10);
        if yp >= 0
            if yp_scaled < 10
                yp_str = sprintf('Y0%d', yp_scaled);
            else
                yp_str = sprintf('Y%d', yp_scaled);
            end
        else
            if yp_scaled < 10
                yp_str = sprintf('YN0%d', yp_scaled);
            else
                yp_str = sprintf('YN%d', yp_scaled);
            end
        end
        
        % Create timestamped folder for saving figures (using consistent timestamp)
        % All motion analysis figures now go to unified 'Rotate_Clamp' directory
        figures_base = fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', 'Rotate_Clamp', 'Rotated_Clamp', 'Figures');
        figures_folder_name = sprintf('%s_mode_%d_%s_%s', timestamp_str, rod_mode, xp_str, yp_str);
        figures_folder = fullfile(figures_base, figures_folder_name);
        
        if ~exist(figures_base, 'dir')
            mkdir(figures_base);
            fprintf('✓ Created figures base folder: %s\\n', figures_base);
        end
        if ~exist(figures_folder, 'dir')
            mkdir(figures_folder);
            fprintf('✓ Created figures folder: %s\\n', figures_folder);
        end

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %%          1. Loading the initial deformed rod

        %   IN     Structure in which are geometric and mechanical parameters
        %     IN.L     length of the rod
        %     IN.N     number of nodes of the rod for R-K integration
        %     IN.EI    Stiffness of the angular component of deformation
        %     IN.px_0       X coordinate of clamped origin
        %     IN.py_0       Y coordinate of clamped origin 
        %     IN.theta_0    Orientation of clamped origin

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Load rod structure
        %load('CLampedPinnedRod_sol_1_mode_2_X02.mat') ;

        % Construct parametric filename from input parameters
        rod_filename = ['CLampedPinnedRod_sol_' num2str(sol_number) '_mode_' num2str(rod_mode) '_' xp_suffix '_' yp_suffix '.mat'];
        fprintf('Loading rod structure from: %s\\n', rod_filename);
        load(rod_filename);


        XP = IN.px_end ;
        YP = IN.py_end ;

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Plot Loaded Rod  
        %fontsiz = 10 ;
        font_size = 10 ;
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        fig_rod0 = figure('Position',[60,60,1000,900]);
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        			clf; % Clear figure to avoid overlay issues
        			grid on; 
        			axis equal;  % Use equal axis scaling for proper rod shape
        			hold on;
        xlabel('x [m]'); ylabel('y [m]');
        quiver( [0 0], [0 0], [0.2 0], [0 0.2], 'k', ...
                'linewidth', 1, 'AutoScale', 'off', 'MaxHeadSize', 0.5) ;
        			text( 0, 0.3, 'Y', 'Units', 'data', 'FontSize', font_size, ...
            			'HorizontalAlignment', 'center') ;
        			text( 0.3, 0, 'X', 'Units', 'data', 'FontSize', font_size, ...
            			'HorizontalAlignment', 'center') ;

        title(['Loaded Rod: ', ' X_P = ',num2str(OUT.px(end)), ' Y_P = ',num2str(OUT.py(end))]);

        			% Validate and plot rod shape with improved visualization
        			if ~isempty(OUT.px) && ~isempty(OUT.py) && length(OUT.px) == length(OUT.py)
            			% Plot rod shape with markers and line
            			plot(OUT.px, OUT.py, 'k-', 'Linewidth', 2); 
            			hold on;
            			plot(OUT.px, OUT.py, 'ko', 'MarkerSize', 4, 'MarkerFaceColor', 'k');
            
            			% Ensure proper axis scaling
            			x_range = max(OUT.px) - min(OUT.px);
            			y_range = max(OUT.py) - min(OUT.py);
            			margin = 0.1 * max(x_range, y_range);
            
            			if margin > 0
                			xlim([min(OUT.px) - margin, max(OUT.px) + margin]);
                			ylim([min(OUT.py) - margin, max(OUT.py) + margin]);
            			end
        			else
            			fprintf('Warning: Rod data (OUT.px, OUT.py) is empty or inconsistent\\n');
        			end
        % plot(OUT.px(1), OUT.py(1),'ks','MarkerSize',20,'MarkerFaceColor','k') ;
        % Rotational actuator
        b = 0.01 ;
            th1rot = [ 0.25*pi linspace( 0.5*pi, 1.5*pi, 361 ) 1.75*pi ]  ;
            xrot = b*cos(th1rot) ;
            yrot = b*sin(th1rot) ;
            xrot([1 end]) = 4*sqrt(2)*b*cos(th1rot([1 end])) ;
            yrot([1 end]) = sqrt(2)*b*sin(th1rot([1 end])) ;
            xrot = [ xrot xrot(1) ] + OUT.px(1) ;
            yrot = [ yrot yrot(1) ] + OUT.py(1) ;
            fill(xrot, yrot, 'k', 'EdgeColor', 'none') ;

        plot(OUT.px(end), OUT.py(end),'ks','MarkerSize',20,'MarkerFaceColor','k') ;
        plot(OUT.px(end), OUT.py(end),'.w','MarkerSize',20,'MarkerFaceColor','w') ;

        % Plot end-point force
        R =  sqrt(OUT.nx(1)^2+OUT.ny(1)^2) ;
        quiver( [OUT.px(end)], [OUT.py(end)], [0.2*OUT.nx(end)/R], [0.2*OUT.ny(end)/R], 'b', 'linewidth', 3, 'MaxHeadSize', 0.5) ;

        %   X Y limits for figure
        xlim([-0.4 0.9])
        ylim([-0.5 0.5])
        
        % Save loaded rod plot - ensure current figure is focused
        loaded_rod_filename = sprintf('%s_mode_%d_%s_%s_Loaded_Rod', timestamp_str, rod_mode, xp_str, yp_str);
        figure(fig_rod0); % Explicitly focus on this figure
        saveas(gcf, fullfile(figures_folder, [loaded_rod_filename '.png']));
        saveas(gcf, fullfile(figures_folder, [loaded_rod_filename '.fig']));
        fprintf('✓ Saved loaded rod plot to figures folder\\n');

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        fig_rod0_theta_vs_s = figure('Position',[60,60,1000,900]);
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        grid ;   hold on ;
        xlabel('s [m]'); ylabel('\\theta [rad]'); 
        title('Loaded Rod: slope vs arc length');
        sz  =   size(OUT.theta);
        s   =    linspace(0,IN.L,sz(2));
        % Plot 
        plot( s , OUT.theta ,'b-o', 'Linewidth', 2) ; 
        
        % Save theta vs s plot - ensure current figure is focused
        theta_vs_s_filename = sprintf('%s_mode_%d_%s_%s_Loaded_Rod_Theta_vs_S', timestamp_str, rod_mode, xp_str, yp_str);
        figure(fig_rod0_theta_vs_s); % Explicitly focus on this figure
        saveas(gcf, fullfile(figures_folder, [theta_vs_s_filename '.png']));
        saveas(gcf, fullfile(figures_folder, [theta_vs_s_filename '.fig']));
        fprintf('✓ Saved theta vs s plot to figures folder\\n'); 

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        fig_rod0_curvature_vs_s = figure('Position',[60,60,1000,900]);
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        grid ;   hold on ;
        xlabel('s [m]'); ylabel('\\kappa [-]'); 
        title('Loaded Rod: curvature vs arc length');
        sz  =   size(OUT.theta);
        s   =    linspace(0,IN.L,sz(2));
        % Plot 
        plot( s , OUT.m/IN.EI ,'g-o', 'Linewidth', 2) ; 
        
        % Save curvature vs s plot - ensure current figure is focused
        curvature_vs_s_filename = sprintf('%s_mode_%d_%s_%s_Loaded_Rod_Curvature_vs_S', timestamp_str, rod_mode, xp_str, yp_str);
        figure(fig_rod0_curvature_vs_s); % Explicitly focus on this figure
        saveas(gcf, fullfile(figures_folder, [curvature_vs_s_filename '.png']));
        saveas(gcf, fullfile(figures_folder, [curvature_vs_s_filename '.fig']));
        fprintf('✓ Saved curvature vs s plot to figures folder\\n'); 

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        fig_rod0_curvature_vs_theta = figure('Position',[60,60,1000,900]);
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        grid ;   hold on ;
        xlabel('\\theta [rad]'); ylabel('\\kappa [-]'); 
        title('Loaded Rod: curvature vs slope');

        % Plot 
        plot( OUT.theta , OUT.m/IN.EI ,'b-', 'Linewidth', 2) ; 
        plot(OUT.theta(1) , OUT.m(1)/IN.EI,'ko','MarkerSize',10,'MarkerFaceColor','b') ;
        plot(OUT.theta(end) , OUT.m(end)/IN.EI,'ks','MarkerSize',10,'MarkerFaceColor','g') ;
        %   X Y limits for figure
        % xlim([-2*pi 2*pi])
        
        % Save curvature vs theta plot - ensure current figure is focused
        curvature_vs_theta_filename = sprintf('%s_mode_%d_%s_%s_Loaded_Rod_Curvature_vs_Theta', timestamp_str, rod_mode, xp_str, yp_str);
        figure(fig_rod0_curvature_vs_theta); % Explicitly focus on this figure
        saveas(gcf, fullfile(figures_folder, [curvature_vs_theta_filename '.png']));
        saveas(gcf, fullfile(figures_folder, [curvature_vs_theta_filename '.fig']));
        fprintf('✓ Saved curvature vs theta plot to figures folder\\n');
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %%          2. Definition of rotation - using passed parameters

        % Use the rotation angle passed from Julia (already in radians)
        % theta  = 360*pi/180 ;  % OLD: hardcoded 360 degrees  
        % Ntheta  =   72  ;      % OLD: hardcoded 72 steps
        
        % NEW: Use parameters passed from Julia configuration
        % rotation_angle_rad and Ntheta will be passed via @mput in next section
        % delta_theta calculation moved to next MATLAB block after @mput

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        """
        # Send parameters to MATLAB 
        @mput rotation_angle_rad Ntheta last_solved_trajectory sol_number xp_suffix yp_suffix xp yp rod_mode
        
        # Execute the main MATLAB solver algorithm with error detection
        # This replicates  AA_Rotate_Clamp_FixedTip.m
        @mput matlab_project_root timestamp_str last_solved_trajectory
        
        println("🔄 Starting MATLAB solver execution...")
        
        # Check if the required rod data file exists before proceeding
        expected_rod_file = "CLampedPinnedRod_sol_$(sol_number)_mode_$(Int(rod_mode))_$(xp_suffix)_$(yp_suffix).mat"
        rod_data_path = joinpath(project_root, "dataset", "MATLAB code", "Learning_Data_ClampedPinned_Rod_IK", "Rotate_Clamp", "Rotated_Clamp", expected_rod_file)
        
        if !isfile(rod_data_path)
            println("\n❌ SOLVER CANNOT PROCEED")
            println("✗ Required rod data file not found: $expected_rod_file")
            println("✗ Expected location: $rod_data_path")
            println("\n📋 Available rod data files:")
            rod_dir = joinpath(project_root, "dataset", "MATLAB code", "Learning_Data_ClampedPinned_Rod_IK", "Rotate_Clamp", "Rotated_Clamp")
            if isdir(rod_dir)
                for file in readdir(rod_dir)
                    if endswith(file, ".mat") && startswith(file, "CLampedPinnedRod")
                        println("   ✓ $file")
                    end
                end
            end
            println("\n💡 Try using one of the available xp values:")
            println("   - xp = 0.2 (files with X02)")
            println("   - xp = 0.5 (files with X05)")
            println("\n❌ SOLVER FAILED - Missing required data file")
            return false
        end
        
        println("✓ Found required rod data file: $expected_rod_file")
        
        # due to clear command defined previously in the previous Matlab block, which erase all the variables, it must be defined in this block
        matlab_execution_successful = false
        try
            mat"""
        fprintf('⏳ Running solver...\\n');
        
        % Define font size for plotting to avoid conflict with MATLAB's fontsize function
        font_size = 10;

        % Ensure variables are double precision
        % theta = double(theta);  % OLD: theta variable no longer used
        rotation_angle_rad = double(rotation_angle_rad);  % NEW: use rotation_angle_rad
        Ntheta = double(Ntheta);

        % Recalculate delta_theta since it wasn't persisted from previous block
        delta_theta = rotation_angle_rad / Ntheta;
        
        % Set project root and timestamp for this MATLAB block
        project_root = matlab_project_root;
        
        % Re-add paths after previous clear statement
        addpath(fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK'));
        addpath(fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', 'Rotate_Clamp'));
        addpath(fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', 'Rotate_Clamp', 'Functions'));
        addpath(fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', 'Rotate_Clamp', 'Rotated_Clamp'));
        
        % Change to the data directory where the rod data files are located
        data_dir = fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', 'Rotate_Clamp', 'Rotated_Clamp');
        cd(data_dir);
        fprintf('Changed directory to: %s\\n', pwd);
        
        % Reload the rod data file to get IN, OUT, XP, YP variables
        rod_filename = ['CLampedPinnedRod_sol_' num2str(sol_number) '_mode_' num2str(rod_mode) '_' xp_suffix '_' yp_suffix '.mat'];
        fprintf('Reloading rod structure from: %s\\n', rod_filename);
        
        % Load the file directly from the current directory
        if exist(rod_filename, 'file') == 2
            load(rod_filename);
            fprintf('✓ Rod data loaded successfully\\n');
        else
            error('Rod data file %s not found in %s', rod_filename, pwd);
        end
        
        % Re-extract XP and YP from loaded data
        XP = IN.px_end;
        YP = IN.py_end;

        % Setup figures folder for saving plots (using consistent timestamp)
        figures_base = fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', 'Rotate_Clamp', 'Rotated_Clamp', 'Figures');
        
        % Recreate xp_str and yp_str variables for figure naming (using passed xp, yp, mode values)
        % Format xp value for folder naming (e.g., 0.2 -> X02, 0.5 -> X05, -0.2 -> XN02)
        xp_scaled = abs(round(xp * 10));
        if xp >= 0
            if xp_scaled < 10
                xp_str = sprintf('X0%d', xp_scaled);
            else
                xp_str = sprintf('X%d', xp_scaled);
            end
        else
            % Handle negative values
            if xp_scaled < 10
                xp_str = sprintf('XN0%d', xp_scaled);
            else
                xp_str = sprintf('XN%d', xp_scaled);
            end
        end
        
        % Format yp value for folder naming (e.g., 0.0 -> Y00, 0.5 -> Y05, -0.3 -> YN03)
        yp_scaled = round(abs(yp) * 10);
        if yp >= 0
            if yp_scaled < 10
                yp_str = sprintf('Y0%d', yp_scaled);
            else
                yp_str = sprintf('Y%d', yp_scaled);
            end
        else
            if yp_scaled < 10
                yp_str = sprintf('YN0%d', yp_scaled);
            else
                yp_str = sprintf('YN%d', yp_scaled);
            end
        end
        
        % Create folder name with timestamp, mode, xp and yp identifiers
        figures_folder_name = sprintf('%s_mode_%d_%s_%s', timestamp_str, rod_mode, xp_str, yp_str);
        figures_folder = fullfile(figures_base, figures_folder_name);
        
        if ~exist(figures_base, 'dir')
            mkdir(figures_base);
            fprintf('✓ Created figures base folder: %s\\n', figures_base);
        end
        if ~exist(figures_folder, 'dir')
            mkdir(figures_folder);
            fprintf('✓ Created figures folder: %s\\n', figures_folder);
        end

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %%          3. Run along

        % Prepare Plot for Motion:
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        fig1 = figure('Position',[600,60,1000,900]);
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        grid ; axis image ;  hold on ;
        xlabel('x [m]'); ylabel('y [m]'); 
        quiver( [0 0], [0 0], [0.2 0], [0 0.2], 'k', ...
                'linewidth', 1, 'AutoScale', 'off', 'MaxHeadSize', 0.5) ;
        text( 0, 0.3, 'Y', 'Units', 'data', 'FontSize', font_size, ...
            'HorizontalAlignment', 'center') ;
        text( 0.3, 0, 'X', 'Units', 'data', 'FontSize', font_size, ...
            'HorizontalAlignment', 'center') ;

        %   X Y limits for figure
        xlim([-0.4 0.9])
        ylim([-0.5 0.5])

        % Prepare Phase Plot
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        fig2 = figure('Position',[600,60,1000,900]);
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        grid ;  
        hold on ;
        title('Phase Plot')
        xlabel('\\theta [rad]','FontSize',14); 
        ylabel('\\kappa [-]','FontSize',14); 

        % Prepare Theta vs Initial curvature Plot
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        fig3 = figure('Position',[600,60,1000,900]);
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        grid ;  
        hold on ;
        title('Theta Input vs Initial curvature \\kappa_{0} Plot')
        xlabel('\\theta_{o} [rad]','FontSize',14); 
        ylabel('\\kappa_{o} [-]','FontSize',14); 

        % Prepare Theta vs R Plot
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        fig4 = figure('Position',[600,60,1000,900]);
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        grid ;  
        hold on ;
        title('Theta Input vs R Plot')
        xlabel('\\theta_{o} [rad]','FontSize',14); 
        ylabel('R [N]','FontSize',14); 

        % Prepare Theta vs Psi Plot
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        fig5 = figure('Position',[600,60,1000,900]);
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        grid ;  
        hold on ;
        title('Theta Input vs \\Psi Plot')
        xlabel('\\theta_{o} [rad]','FontSize',14); 
        ylabel('\\Psi [rad]','FontSize',14); 




        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Start Analysis step by step
        % Start Analysis step by step with memory management
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %   Solve and save solutions from theta_0 = 0º to 360º
        %   There will be N+1 poses for the complete rotation
        
                    fprintf(' Starting computational loop: %d iterations\\n', Ntheta+1);
                    fprintf(' Memory management: clearing variables every 10 iterations\\n');

        %thetaStep   = 0 ;
        for i = 1:(Ntheta+1)
            
                        % Progress monitoring to prevent crashes
                        if mod(i, 10) == 0
                            fprintf('✓ Progress: %d/%d iterations (%.1f%%)\\n', i, Ntheta+1, 100*i/(Ntheta+1));
                            % Memory cleanup every 10 iterations to prevent accumulation
                            if mod(i, 20) == 0
                                fprintf(' Memory cleanup at iteration %d\\n', i);
                                clear('temp*', 'aux*', 'intermediate*');  % Clear temporary variables
                            end
                        end

        % Value of theta of local frame wrt Fixed frame
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            thetaStep   = delta_theta*(i-1) ;  
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


            % New coordinates of P in local frame
            IN.px_end   =  XP*cos(thetaStep) + YP*sin(thetaStep); 
            IN.py_end   = -XP*sin(thetaStep) + YP*cos(thetaStep); 
            
            % Solve IK in local frame
            [ IN, OUT, GUESS, RESID ] = IK_fsolve( IN ) ;
            
            if OUT.sol == 1
            % Transform coordinates to fixed frame to plot them
            pX  =   OUT.px.*cos(thetaStep) - OUT.py.*sin(thetaStep) ;
            pY  =   OUT.px.*sin(thetaStep) + OUT.py.*cos(thetaStep) ;

            % nX  =   OUT.nx.*cos(thetaStep) - OUT.ny.*sin(thetaStep) ;
            % nY  =   OUT.nx.*sin(thetaStep) + OUT.ny.*cos(thetaStep) ;
            
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Save resuts into Learning Data set in fixed frame
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Save Data set:
                Data(1)   =  pX(1) ;
                Data(2)   =  pY(1) ;
                Data(3)   =  OUT.theta(1) + thetaStep ;
                Data(4)   =  OUT.mode ;
                Data(5)   =  pX(end) ;
                Data(6)   =  pY(end) ;
                Data(7)   =  OUT.m(1) ;
                Data(8)   =  OUT.nx(1); %nX(1) ;
                Data(9)   =  OUT.ny(1); %nY(1) ;
                Data(10)  =  sqrt(OUT.nx(1)^2+OUT.ny(1)^2) ;
                Data(11)  =  atan2(OUT.ny(1),OUT.nx(1)) + thetaStep;

                Datab     =  horzcat(Data,pX,pY,OUT.m,OUT.theta + thetaStep) ;

                if i ==1 
                    DataSet  =  Datab ;
                else
                    DataSet  =  vertcat(DataSet, Datab) ;
                end
            OUT_last = OUT ;    
            else
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                % Plot last pose: red
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                figure(fig1)
                title(['\\color{red}{Rotation Ended at: }',num2str(thetaStep*180/pi), ' degrees'])
                plot(pX,pY,'-r', 'Linewidth', 2) ; 
                plot(pX(end), pY(end),'rs','MarkerSize',20,'MarkerFaceColor','r') ;
                plot(pX(end), pY(end),'.w','MarkerSize',20,'MarkerFaceColor','w') ;
                % Rotational actuator
                    b = 0.01 ;
                    th1rot = [ 0.25*pi linspace( 0.5*pi, 1.5*pi, 361 ) 1.75*pi ] ;
                    xrot = b*cos(th1rot) ;
                    yrot = b*sin(th1rot) ;
                    xrot([1 end]) = 4*sqrt(2)*b*cos(th1rot([1 end])) ;
                    yrot([1 end]) = sqrt(2)*b*sin(th1rot([1 end])) ;
                    xrot = [ xrot xrot(1) ]  ;
                    yrot = [ yrot yrot(1) ]  ;
                    % Transform coordinates to fixed frame to plot them
                    xrotF  =   xrot.*cos(thetaStep) - yrot.*sin(thetaStep) ;
                    yrotF  =   xrot.*sin(thetaStep) + yrot.*cos(thetaStep) ;
                    fill(xrotF, yrotF, 'r', 'EdgeColor', 'none') ;

                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                % Plot last pose: Phase Plot
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                figure(fig2)  
                plot(OUT_last.theta + thetaStep, OUT_last.m/IN.EI,'-r', 'Linewidth', 1) ; 
                plot(OUT_last.theta(1) + thetaStep, OUT_last.m(1)/IN.EI,'ko','MarkerSize',10,'MarkerFaceColor','r') ;

                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                % Theta_0 vs Initial curvature Plot
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                figure(fig3)
                plot(DataSet(:,3), DataSet(:,7)/IN.EI,'k-o','MarkerSize',10,'MarkerFaceColor','b') ;

                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                % Plot last pose: Theta_0 vs Initial curvature Plot
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                figure(fig3)   
                plot(OUT_last.theta(1) + thetaStep, OUT_last.m(1)/IN.EI,'ko','MarkerSize',10,'MarkerFaceColor','r') ;

                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                % Plot last pose: Theta_0 vs R Plot
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                figure(fig4)
                plot(DataSet(:,3), sqrt(DataSet(:,8).^2+DataSet(:,9).^2),'k-o','MarkerSize',10,'MarkerFaceColor','b') ;
                plot(OUT_last.theta(1) + thetaStep, sqrt(OUT_last.nx(1)^2+OUT_last.ny(1)^2),'ko','MarkerSize',10,'MarkerFaceColor','r') ;

                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                % Plot last pose: Theta_0 vs Psi Plot
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                figure(fig5)
                plot(DataSet(:,3), atan2(DataSet(:,9),DataSet(:,8)) + thetaStep,'k-o','MarkerSize',10,'MarkerFaceColor','b') ;
                plot(OUT_last.theta(1) + thetaStep, atan2(OUT_last.ny(1),OUT_last.nx(1)) + thetaStep,'ko','MarkerSize',10,'MarkerFaceColor','r') ;

                return
            end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Plot motion
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        figure(fig1)
        plot(pX,pY,'-b', 'Linewidth', 2) ; 
        plot(pX(end), pY(end),'ks','MarkerSize',20,'MarkerFaceColor','k') ;
        plot(pX(end), pY(end),'.w','MarkerSize',20,'MarkerFaceColor','w') ;

        % Rotational actuator
        b = 0.01 ;
            th1rot = [ 0.25*pi linspace( 0.5*pi, 1.5*pi, 361 ) 1.75*pi ] ;
            xrot = b*cos(th1rot) ;
            yrot = b*sin(th1rot) ;
            xrot([1 end]) = 4*sqrt(2)*b*cos(th1rot([1 end])) ;
            yrot([1 end]) = sqrt(2)*b*sin(th1rot([1 end])) ;
            xrot = [ xrot xrot(1) ]  ;
            yrot = [ yrot yrot(1) ]  ;
            % Transform coordinates to fixed frame to plot them
            xrotF  =   xrot.*cos(thetaStep) - yrot.*sin(thetaStep) ;
            yrotF  =   xrot.*sin(thetaStep) + yrot.*cos(thetaStep) ;
            fill(xrotF, yrotF, 'k', 'EdgeColor', 'none') ;

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Phase Plot
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        figure(fig2)  
        plot(OUT.theta + thetaStep, OUT.m/IN.EI,'-', 'Linewidth', 1) ; 
        plot(OUT.theta(1) + thetaStep, OUT.m(1)/IN.EI,'ko','MarkerSize',10,'MarkerFaceColor','b') ;


                % Save DataSet when i = last_solved_trajectory (configurable save)
                if i == last_solved_trajectory
                    % At iteration i, we have stored i trajectories in the DataSet
                    % The angle for trajectory i is (i-1)*delta_theta
                    current_angle_deg = (i-1)*delta_theta*180/pi;
                    fprintf('Saving dataset at iteration %d\\n', i);
                    fprintf('  Trajectories to save: %d (first %d rows of DataSet)\\n', i, i);
                    fprintf('  Last angle to save: %.1f°\\n', current_angle_deg);
                    
                    % Create subset for saving (keep original DataSet for continued computation)
                    DataSetSaved = DataSet(1:i, :);
                    
                    % Construct parametric output filename
                    output_filename = ['LearnigData_Rod_Clamp_Pin_Rot_' xp_suffix '_' yp_suffix '_' num2str(Ntheta) 'sols_mode' num2str(rod_mode) '.mat'];
                    output_file = fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', output_filename);
                    
                    % Save the subset (using temporary variable name)
                    DataSet_temp = DataSetSaved;
                    save(output_file, 'DataSet_temp');
                    fprintf('✓ Learning data saved to: %s (save at iteration %d)\\n', output_file, i);
                    fprintf('✓ Dataset contains %d trajectories (angles 0° to %.1f°)\\n', size(DataSetSaved, 1), current_angle_deg);
                end                
                % Print the current iteration number
                disp(['Iteration: ', num2str(i)]);
        end
        
                    % Memory cleanup after intensive computational loop
                    fprintf('🧹 Final memory cleanup after %d iterations\\n', Ntheta+1);
                    clear('temp*', 'aux*', 'intermediate*');  % Clear temporary variables (preserve thetaStep for figure saving)
                    fprintf('✓ Memory cleanup completed\\n');
                    fprintf('✓ Computational loop finished successfully\\n');
        """
        
            matlab_execution_successful = true
            println("✓ MATLAB solver execution completed")
            
        catch matlab_error
            println("\n❌ MATLAB SOLVER EXECUTION FAILED")
            println("✗ Error: $matlab_error")
            
            if occursin("Rod data file", string(matlab_error))
                println("✗ Missing required rod data file")
                println("💡 The solver requires pre-computed rod data for the specified xp value")
            elseif occursin("Unrecognized function", string(matlab_error))
                println("✗ MATLAB function or variable not found")
                println("💡 This suggests the solver encountered an early failure")
            else
                println("✗ Unknown MATLAB execution error")
            end
            
            matlab_execution_successful = false
        end
        
        # Only proceed with dataset analysis if MATLAB execution was successful
        if !matlab_execution_successful
            println("\n❌ SOLVER FAILED - MATLAB execution unsuccessful")
            return false
        end

        # Get the saved DataSet immediately after the MATLAB loop completes
        println("\n=== CHECKING FOR SAVED DATASET ===")
        
        # Try to retrieve the saved dataset from MATLAB workspace
        saved_dataset_retrieved = false
        try
            @mget DataSet_temp
            println("✓ Successfully retrieved saved DataSet_temp from MATLAB workspace")
            
            num_trajectories = size(DataSet_temp, 1)
            angle_step = 360.0 / Ntheta
            last_angle = (num_trajectories - 1) * angle_step
            last_attempted_angle = num_trajectories * angle_step  # Last saved trajectory angle
            last_attempted_angle = num_trajectories * angle_step  # Last attempted angle (where solver may have stopped)
            total_possible = Int(Ntheta) + 1
            
            println("Generated DataSet size: $(size(DataSet_temp))")
            println("Number of saved trajectories: $(num_trajectories)")
            println("Data points per trajectory: $(size(DataSet_temp, 2))")
            println("Angular range covered: 0° to $(last_attempted_angle)° ($(num_trajectories) trajectories saved, last at $(last_angle)°)")
            println("Save point was configured for iteration $(last_solved_trajectory) (from a total of $(total_possible))")
            
            # Store for final summary
            global saved_dataset_info = (
                size = size(DataSet_temp),
                trajectories = num_trajectories,
                angle_range = last_attempted_angle,
                last_saved_angle = last_angle,
                save_iteration = last_solved_trajectory
            )
            
            saved_dataset_retrieved = true
            println("✓ Dataset information stored for final analysis")
        catch e
            println("⚠ Could not retrieve saved DataSet_temp from MATLAB workspace: $e")
            println("  Will attempt to load from saved file instead...")
        end
        
        # If workspace retrieval failed, try to load the saved file directly
        if !saved_dataset_retrieved && last_solved_trajectory < Int(Ntheta) + 1
            try
                # Construct the expected filename
                @mget project_root xp_suffix yp_suffix Ntheta rod_mode
                filename = "LearnigData_Rod_Clamp_Pin_Rot_$(xp_suffix)_$(yp_suffix)_$(Int(Ntheta))sols_mode$(Int(rod_mode)).mat"
                filepath = joinpath(project_root, "dataset", "MATLAB code", "Learning_Data_ClampedPinned_Rod_IK", filename)
                
                # Add delay to allow file system to complete write operation
                println("⏳ Waiting for file system to complete save operation...")
                sleep(2)  # Wait 2 seconds for file to be fully written
                
                if isfile(filepath)
                    println("✓ Found saved file: $filename")
                    # Load the file using MATLAB - pass filepath as MATLAB variable
                    @mput filepath
                    mat"""
                    load(filepath, 'DataSet_temp');
                    fprintf('✓ Loaded saved DataSet_temp from file\\n');
                    """
                    
                    @mget DataSet_temp
                    num_trajectories = size(DataSet_temp, 1)
                    angle_step = 360.0 / Ntheta
                    last_angle = (num_trajectories - 1) * angle_step
                    
            println("✓ Successfully loaded saved DataSet from file")
            println("Generated DataSet size: $(size(DataSet_temp))")
            println("Number of saved trajectories: $(num_trajectories)")
            println("Data points per trajectory: $(size(DataSet_temp, 2))")
            println("Angular range covered: 0° to $(last_attempted_angle)° ($(num_trajectories) trajectories saved, last at $(last_angle)°)")                    # Store for final summary
                    global saved_dataset_info = (
                        size = size(DataSet_temp),
                        trajectories = num_trajectories,
                        angle_range = last_angle,
                        save_iteration = last_solved_trajectory
                    )
                    
                    saved_dataset_retrieved = true
                    println("✓ Dataset information stored for final analysis")
                else
                    println("⚠ Saved file not found after delay: $filepath")
                    # Try to list files in the directory to help debug
                    dataset_dir = joinpath(project_root, "dataset", "MATLAB code", "Learning_Data_ClampedPinned_Rod_IK")
                    if isdir(dataset_dir)
                        println("📂 Files in dataset directory:")
                        for file in readdir(dataset_dir)
                            if endswith(file, ".mat") && occursin("LearnigData", file)
                                println("   - $file")
                            end
                        end
                    end
                end
            catch load_error
                println("⚠ Could not load saved DataSet from file: $load_error")
            end
        end

        # Continue with any remaining MATLAB operations
        mat"""

        % FIRST PRIORITY: Save dataset if it exists (before any other operations)
        fprintf('\\n=== DATASET SAVE CHECK ===\\n');
        
        % Define xp_str and yp_str variables first (before any usage)
        % Format xp value for folder naming (e.g., 0.2 -> X02, 0.5 -> X05, -0.2 -> XN02)
        if xp >= 0
            xp_str = sprintf('X%02d', round(xp*10));
        else
            xp_str = sprintf('XN%02d', round(abs(xp)*10));
        end
        
        % Format yp value for folder naming (e.g., 0.0 -> Y00, 0.5 -> Y05, -0.3 -> YN03)
        if yp >= 0
            yp_str = sprintf('Y%02d', round(yp*10));
        else
            yp_str = sprintf('YN%02d', round(abs(yp)*10));
        end
        
        if exist('DataSet', 'var') && ~isempty(DataSet) && size(DataSet, 1) > 0
            actual_trajectories = size(DataSet, 1);
            fprintf('DataSet exists with %d trajectories\\n', actual_trajectories);
            fprintf('Expected save point: %d\\n', last_solved_trajectory);
            fprintf('Total planned trajectories: %d\\n', Ntheta);
            
            % Check if we already saved at the correct point and should not overwrite
            if actual_trajectories > last_solved_trajectory
                fprintf('CASE: Computation continued beyond save point (already saved at %d)\\n', last_solved_trajectory);
                fprintf('Skipping final save to preserve correct trajectory count\\n');
                save_needed = false;
            elseif actual_trajectories < last_solved_trajectory
                fprintf('CASE: Early termination (stopped before save point)\\n');
                save_reason = 'early_termination';
                save_needed = true;
            elseif actual_trajectories == last_solved_trajectory
                fprintf('CASE: Normal save point reached exactly\\n');
                save_reason = 'normal_save';
                save_needed = true;
            end
            
            if save_needed
                % Construct parametric output filename
                output_filename = ['LearnigData_Rod_Clamp_Pin_Rot_' xp_suffix '_' yp_suffix '_' num2str(Ntheta) 'sols_mode' num2str(rod_mode) '.mat'];
                output_file = fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', output_filename);
                
                fprintf('Output filename: %s\\n', output_filename);
                fprintf('Full path: %s\\n', output_file);
                fprintf('Saving to: %s\\n', output_file);
                
                % Ensure the directory exists
                [output_dir, ~, ~] = fileparts(output_file);
                if ~exist(output_dir, 'dir')
                    mkdir(output_dir);
                    fprintf('✓ Created directory: %s\\n', output_dir);
                else
                    fprintf('✓ Directory exists: %s\\n', output_dir);
                end
                
                % Save the complete dataset (using temporary variable name)
                DataSet_temp = DataSet;
                
                try
                    save(output_file, 'DataSet_temp');
                    fprintf('✓ SUCCESS: Learning data saved (%s)\\n', save_reason);
                    fprintf('✓ Dataset contains %d trajectories\\n', actual_trajectories);
                    fprintf('✓ File saved to: %s\\n', output_file);
                catch save_error
                    fprintf('✗ ERROR saving dataset: %s\\n', save_error.message);
                end
            else
                fprintf('No save needed - data already saved correctly at iteration %d\\n', last_solved_trajectory);
            end
        else
            fprintf('✗ DataSet not available for saving\\n');
            if ~exist('DataSet', 'var')
                fprintf('  - DataSet variable does not exist\\n');
            elseif isempty(DataSet)
                fprintf('  - DataSet is empty\\n');
            elseif size(DataSet, 1) == 0
                fprintf('  - DataSet has zero rows\\n');
            end
        end

        % Set up figures folder with timestamp and parameter encoding
        rotate_clamp_folder = fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', 'Rotate_Clamp', 'Rotated_Clamp');
        figures_main_folder = fullfile(rotate_clamp_folder, 'Figures');
        
        % Create timestamped subfolder with parameter encoding
        figures_folder = fullfile(figures_main_folder, [timestamp_str '_mode_' num2str(rod_mode) '_' xp_str '_' yp_str]);
        
        % Create the directory if it doesn't exist
        if ~exist(figures_folder, 'dir')
            mkdir(figures_folder);
            fprintf('✓ Created figures directory: %s\\n', figures_folder);
        end

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Theta_0 vs Initial curvature Plot
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        if exist('fig3', 'var') && isvalid(fig3)
            figure(fig3)
            plot(DataSet(:,3), DataSet(:,7)/IN.EI,'k-o','MarkerSize',10,'MarkerFaceColor','b') ;
        else
            fprintf('⚠ Figure fig3 not available, skipping plot\\n');
        end

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Theta_0 vs R Plot
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        if exist('fig4', 'var') && isvalid(fig4)
            figure(fig4)   
            plot(DataSet(:,3), DataSet(:,10),'k-o','MarkerSize',10,'MarkerFaceColor','b') ;
        else
            fprintf('⚠ Figure fig4 not available, skipping plot\\n');
        end

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Theta_0 vs Psi Plot
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        if exist('fig5', 'var') && isvalid(fig5)
            figure(fig5)   
            plot(DataSet(:,3), DataSet(:,11) ,'k-o','MarkerSize',10,'MarkerFaceColor','b') ;
        else
            fprintf('⚠ Figure fig5 not available, skipping plot\\n');
        end



        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Plot last pose: red
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        figure(fig1)
                title(['\\color{red}{Rotation Ended at: }',num2str(thetaStep*180/pi), ' degrees'])
                plot(pX,pY,'-r', 'Linewidth', 2) ; 
                plot(pX(end), pY(end),'rs','MarkerSize',20,'MarkerFaceColor','r') ;
                plot(pX(end), pY(end),'.w','MarkerSize',20,'MarkerFaceColor','w') ;
                % Rotational actuator
                    b = 0.01 ;
                    th1rot = [ 0.25*pi linspace( 0.5*pi, 1.5*pi, 361 ) 1.75*pi ] ;
                    xrot = b*cos(th1rot) ;
                    yrot = b*sin(th1rot) ;
                    xrot([1 end]) = 4*sqrt(2)*b*cos(th1rot([1 end])) ;
                    yrot([1 end]) = sqrt(2)*b*sin(th1rot([1 end])) ;
                    xrot = [ xrot xrot(1) ]  ;
                    yrot = [ yrot yrot(1) ]  ;
                    % Transform coordinates to fixed frame to plot them
                    xrotF  =   xrot.*cos(thetaStep) - yrot.*sin(thetaStep) ;
                    yrotF  =   xrot.*sin(thetaStep) + yrot.*cos(thetaStep) ;
                    fill(xrotF, yrotF, 'r', 'EdgeColor', 'none') ;

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Plot last pose: Phase Plot
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        figure(fig2)  
        plot(OUT.theta + thetaStep, OUT.m/IN.EI,'-r', 'Linewidth', 1) ; 
        plot(OUT.theta(1) + thetaStep, OUT.m(1)/IN.EI,'ko','MarkerSize',10,'MarkerFaceColor','r') ;
        plot(DataSet(:,3), DataSet(:,7)/IN.EI,'-k') ;

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Plot last pose: Theta_0 vs Initial curvature Plot
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        figure(fig3)
        plot(OUT.theta(1) + thetaStep, OUT.m(1)/IN.EI,'ko','MarkerSize',10,'MarkerFaceColor','r') ;

            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Plot last pose: Theta_0 vs R Plot
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            figure(fig4)   
            plot(OUT.theta(1) + thetaStep, sqrt(OUT.nx(1)^2+OUT.ny(1)^2),'ko','MarkerSize',10,'MarkerFaceColor','r') ;

            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Plot last pose: Theta_0 vs Psi Plot
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            figure(fig5)   
            plot(OUT.theta(1) + thetaStep, atan2(OUT.ny(1),OUT.nx(1)) + thetaStep,'ko','MarkerSize',10,'MarkerFaceColor','r') ;

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Save all rotation figures to the figures folder
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
        fprintf('\\n=== SAVING FIGURES ===\\n');
        fprintf('Figures folder: %s\\n', figures_folder);
        
        % Debug: Check which figures exist and are valid
        fprintf('\\n--- FIGURE VALIDITY CHECK ---\\n');
        for fig_num = 1:5
            fig_var = sprintf('fig%d', fig_num);
            if exist(fig_var, 'var')
                fig_handle = eval(fig_var);
                if isvalid(fig_handle)
                    fprintf('✓ %s exists and is valid\\n', fig_var);
                else
                    fprintf('⚠ %s exists but is invalid\\n', fig_var);
                end
            else
                fprintf('✗ %s does not exist\\n', fig_var);
            end
        end
        fprintf('--- END FIGURE VALIDITY CHECK ---\\n\\n');
        
        % Save Motion Plot (fig1)
        if exist('fig1', 'var') && isvalid(fig1)
            motion_filename = sprintf('%s_mode_%d_%s_%s_Motion_Plot', timestamp_str, rod_mode, xp_str, yp_str);
            figure(fig1);
            saveas(gcf, fullfile(figures_folder, [motion_filename '.png']));
            saveas(gcf, fullfile(figures_folder, [motion_filename '.fig']));
            fprintf('✓ Saved motion plot: %s\\n', motion_filename);
        else
            fprintf('⚠ Figure fig1 not available, skipping motion plot save\\n');
        end
        
        % Save Phase Plot (fig2)
        if exist('fig2', 'var') && isvalid(fig2)
            phase_filename = sprintf('%s_mode_%d_%s_%s_Phase_Plot', timestamp_str, rod_mode, xp_str, yp_str);
            figure(fig2);
            saveas(gcf, fullfile(figures_folder, [phase_filename '.png']));
            saveas(gcf, fullfile(figures_folder, [phase_filename '.fig']));
            fprintf('✓ Saved phase plot: %s\\n', phase_filename);
        else
            fprintf('⚠ Figure fig2 not available, skipping phase plot save\\n');
        end
        
        % Save Theta vs Initial Curvature Plot (fig3)
        if exist('fig3', 'var') && isvalid(fig3)
            theta_curvature_filename = sprintf('%s_mode_%d_%s_%s_Theta_vs_Initial_Curvature', timestamp_str, rod_mode, xp_str, yp_str);
            figure(fig3);
            saveas(gcf, fullfile(figures_folder, [theta_curvature_filename '.png']));
            saveas(gcf, fullfile(figures_folder, [theta_curvature_filename '.fig']));
            fprintf('✓ Saved theta vs initial curvature plot: %s\\n', theta_curvature_filename);
        else
            fprintf('⚠ Figure fig3 not available, skipping theta vs curvature plot save\\n');
        end
        
        % Save Theta vs R Plot (fig4)
        if exist('fig4', 'var') && isvalid(fig4)
            theta_r_filename = sprintf('%s_mode_%d_%s_%s_Theta_vs_R', timestamp_str, rod_mode, xp_str, yp_str);
            figure(fig4);
            saveas(gcf, fullfile(figures_folder, [theta_r_filename '.png']));
            saveas(gcf, fullfile(figures_folder, [theta_r_filename '.fig']));
            fprintf('✓ Saved theta vs R plot: %s\\n', theta_r_filename);
        else
            fprintf('⚠ Figure fig4 not available, skipping theta vs R plot save\\n');
        end
        
        % Save Theta vs Psi Plot (fig5)
        if exist('fig5', 'var') && isvalid(fig5)
            theta_psi_filename = sprintf('%s_mode_%d_%s_%s_Theta_vs_Psi', timestamp_str, rod_mode, xp_str, yp_str);
            figure(fig5);
            saveas(gcf, fullfile(figures_folder, [theta_psi_filename '.png']));
            saveas(gcf, fullfile(figures_folder, [theta_psi_filename '.fig']));
            fprintf('✓ Saved theta vs psi plot: %s\\n', theta_psi_filename);
        else
            fprintf('⚠ Figure fig5 not available, skipping theta vs psi plot save\\n');
        end
        
        % Summary of saved figures
        fprintf('\\n=== FIGURES SAVED ===\\n');
        fprintf('All plots saved to: %s\\n', figures_folder);
        
        % Ensure all file operations are flushed to disk
        drawnow;  % Force completion of any pending graphics operations
        pause(0.1);  % Small pause to ensure file system operations complete
        fprintf('Saved figures:\\n');
        fprintf('- %s.png/.fig (Initial rod shape)\\n', [timestamp_str '_mode_' num2str(rod_mode) '_' xp_str '_' yp_str '_Loaded_Rod']);
        fprintf('- %s.png/.fig (Theta vs S)\\n', [timestamp_str '_mode_' num2str(rod_mode) '_' xp_str '_' yp_str '_Loaded_Rod_Theta_vs_S']);
        fprintf('- %s.png/.fig (Curvature vs S)\\n', [timestamp_str '_mode_' num2str(rod_mode) '_' xp_str '_' yp_str '_Loaded_Rod_Curvature_vs_S']);
        fprintf('- %s.png/.fig (Curvature vs Theta)\\n', [timestamp_str '_mode_' num2str(rod_mode) '_' xp_str '_' yp_str '_Loaded_Rod_Curvature_vs_Theta']);
        fprintf('- %s.png/.fig (Motion plot)\\n', [timestamp_str '_mode_' num2str(rod_mode) '_' xp_str '_' yp_str '_Motion_Plot']);
        fprintf('- %s.png/.fig (Phase plot)\\n', [timestamp_str '_mode_' num2str(rod_mode) '_' xp_str '_' yp_str '_Phase_Plot']);
        fprintf('- %s.png/.fig (Theta vs Initial Curvature)\\n', [timestamp_str '_mode_' num2str(rod_mode) '_' xp_str '_' yp_str '_Theta_vs_Initial_Curvature']);
        fprintf('- %s.png/.fig (Theta vs R)\\n', [timestamp_str '_mode_' num2str(rod_mode) '_' xp_str '_' yp_str '_Theta_vs_R']);
        fprintf('- %s.png/.fig (Theta vs Psi)\\n', [timestamp_str '_mode_' num2str(rod_mode) '_' xp_str '_' yp_str '_Theta_vs_Psi']);
        fprintf('Total figures saved: 9 plots (18 files with .png and .fig formats)\\n');

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Save in a *.mat file the Learning Data Found

        % Original MATLAB logic: save('LearnigData_Rod_Clamp_Pin_Rot_X02_72sol_mod2','DataSet')
        % Modified to be parametric and respect save_at_step configuration
        
        % Only save final dataset if save_at_step was set to full rotation
        if last_solved_trajectory == (Ntheta+1)
            % Construct parametric output filename
            output_filename = ['LearnigData_Rod_Clamp_Pin_Rot_' xp_suffix '_' yp_suffix '_' num2str(Ntheta) 'sols_mode' num2str(rod_mode) '.mat'];
            output_file = fullfile(project_root, 'dataset', 'MATLAB code', 'Learning_Data_ClampedPinned_Rod_IK', output_filename);
            
            % For full rotation save, include all trajectories
            save(output_file, 'DataSet');
            fprintf('✓ Learning data saved to: %s (final save after full rotation)\\n', output_file);
        else
            % Report actual saved trajectory count, not the save configuration
            if exist('DataSet_temp', 'var')
                actual_saved = size(DataSet_temp, 1);
                fprintf('✓ Data already saved: %d trajectories (saved at early termination)\\n', actual_saved);
            else
                fprintf('✓ Data already saved at configured iteration %d (no final save needed)\\n', last_solved_trajectory);
            end
        end

        """

        # Try to get DataSet back to Julia for analysis (but don't fail if MATLAB engine is unavailable)
        println("\n=== MATLAB SOLVER RESULTS ===")
        println("✓ Learning data generation completed successfully")
        
        # First, show information about the complete computation
        try
            @mget DataSet
            full_trajectories = size(DataSet, 1)
            angle_step = 360.0 / Ntheta
            full_last_angle = (full_trajectories - 1) * angle_step
            println("\n--- COMPLETE COMPUTATION INFO ---")
            println("Total computed trajectories: $(full_trajectories)")
            println("Full angular range computed: 0° to $(full_last_angle)°")
            println("All iterations (1 to $(full_trajectories)) were computed successfully")
        catch
            println("⚠ Could not retrieve complete DataSet for analysis")
        end
        
        # Then show information about what was actually saved
        if @isdefined(saved_dataset_info)
            println("\n--- SAVED DATASET INFO ---")
            println("Generated DataSet size: $(saved_dataset_info.size)")
            println("Number of saved trajectories: $(saved_dataset_info.trajectories)")
            println("Data points per trajectory: $(saved_dataset_info.size[2])")
            println("Angular range covered: 0° to $(saved_dataset_info.angle_range)° (computation reached this angle)")
            println("Last saved trajectory at: $(saved_dataset_info.last_saved_angle)°")
            println("✓ Saved at configured iteration $(saved_dataset_info.save_iteration): $(saved_dataset_info.trajectories) trajectories")
            if saved_dataset_info.save_iteration < Int(Ntheta) + 1
                excluded_count = Int(Ntheta) + 1 - saved_dataset_info.save_iteration
                println("✓ Dataset excludes $(excluded_count) trajectories beyond $(saved_dataset_info.last_saved_angle)° (computation continued for visualization)")
            end
        else
            # Fallback to original behavior
            try
                @mget DataSet
                
                num_trajectories = size(DataSet, 1)
                println("\n--- DATASET INFO ---")
                println("Generated DataSet size: $(size(DataSet))")
                println("Number of saved trajectories: $(num_trajectories)")
                println("Data points per trajectory: $(size(DataSet, 2))")
                
                # Calculate the angular range covered - show where computation actually ended
                angle_step = 360.0 / Ntheta
                last_attempted_angle = num_trajectories * angle_step  # Where computation ended
                last_saved_angle = (num_trajectories - 1) * angle_step  # Last saved trajectory
                println("Angular range covered: 0° to $(last_attempted_angle)°")
                
                # Verify that saved dataset matches expected save_at_step
                if num_trajectories == last_solved_trajectory
                    println("✓ Saved at configured iteration $(last_solved_trajectory): $(num_trajectories) trajectories")
                    if last_solved_trajectory < Int(Ntheta) + 1
                        println("✓ Dataset excludes trajectories beyond $(last_saved_angle)° (computation continued for visualization)")
                    end
                else
                    println("⚠ Unexpected trajectory count: $(num_trajectories) (expected $(last_solved_trajectory))")
                    println("  Save point was configured for iteration $(last_solved_trajectory)")
                end
            catch matlab_error
                println("⚠ Could not retrieve DataSet from MATLAB for analysis (MATLAB engine may have closed)")
                println("✓ However, the computation completed successfully and files were saved")
            end
        end

        # Return success - computation completed
        println("\n=== FINAL SOLVER STATUS ===")
        
        # Check if the solver actually succeeded by verifying file creation
        solver_succeeded = false
        dataset_file_exists = false
        
        try
            # Check if the expected output file was created
            @mget project_root xp_suffix yp_suffix Ntheta rod_mode
            expected_filename = "LearnigData_Rod_Clamp_Pin_Rot_$(xp_suffix)_$(yp_suffix)_$(Int(Ntheta))sols_mode$(Int(rod_mode)).mat"
            expected_filepath = joinpath(project_root, "dataset", "MATLAB code", "Learning_Data_ClampedPinned_Rod_IK", expected_filename)
            
            if isfile(expected_filepath)
                dataset_file_exists = true
                println("✓ Dataset file found: $expected_filename")
                
                # Try to get basic info about what was actually computed
                if @isdefined(saved_dataset_info)
                    println("✓ Learning data generation completed successfully")
                    println("✓ Generated $(saved_dataset_info.trajectories) trajectories")
                    println("✓ Dataset saved to file")
                    solver_succeeded = true
                else
                    # File exists but we don't have info - try to load and check
                    try
                        @mput expected_filepath
                        mat"""
                        load(expected_filepath, 'DataSet_temp');
                        """
                        @mget DataSet_temp
                        num_saved = size(DataSet_temp, 1)
                        println("✓ Learning data generation completed successfully")
                        println("✓ Generated $(num_saved) trajectories")
                        println("✓ Dataset saved to file")
                        solver_succeeded = true
                    catch
                        println("⚠ File exists but could not verify content")
                        solver_succeeded = false
                    end
                end
            else
                println("✗ Expected dataset file not found: $expected_filename")
                println("✗ File path checked: $expected_filepath")
                solver_succeeded = false
            end
        catch e
            println("⚠ Could not verify file creation: $e")
            solver_succeeded = false
        end
        
        # Final status
        if solver_succeeded && dataset_file_exists
            println("\n✅ CLAMP FIXED ROD SOLVER COMPLETED SUCCESSFULLY")
            return true
        else
            println("\n❌ CLAMP FIXED ROD SOLVER FAILED")
            println("✗ No dataset file was created")
            println("✗ The solver may have encountered convergence issues")
            println("✗ Try with different parameters (e.g., smaller xp value)")
            return false
        end
      
        catch matlab_error
            if isa(matlab_error, InterruptException)
                println("\n⚠️  SOLVER INTERRUPTED BY USER")
                println("✓ Checking for partial results...")
                
                # Check if dataset was saved despite interruption
                expected_file = joinpath(project_root, "dataset", "MATLAB code", "Learning_Data_ClampedPinned_Rod_IK", 
                                       "LearnigData_Rod_Clamp_Pin_Rot_$(xp_suffix)_$(yp_suffix)_72sol_mod$(mode).mat")
                
                if isfile(expected_file)
                    println("✅ SUCCESS: Dataset was saved before interruption!")
                    println("✓ File location: $(expected_file)")
                    println("✓ The solver completed successfully up to the interruption point")
                    return true
                else
                    println("⚠️  No complete dataset found after interruption")
                    return false
                end
                
            elseif isa(matlab_error, MATLAB.MEngineError)
                println("\n❌ MATLAB SOLVER EXECUTION FAILED")
                println("✗ Error: $(matlab_error)")
                println("💡 MATLAB Engine Error Solutions:")
                println("1. Restart Julia and try again")
                println("2. Close any existing MATLAB instances")
                println("3. Run 'matlab -regserver' as Administrator")
                println("4. Check MATLAB license availability")
                println("\n❌ SOLVER FAILED - MATLAB execution unsuccessful")
                return false
            else
                println("\n❌ MATLAB SOLVER EXECUTION FAILED")
                println("✗ Unknown MATLAB execution error")
                println("✗ Error details: $(matlab_error)")
                println("\n❌ SOLVER FAILED - MATLAB execution unsuccessful")
                return false
            end
        end
      
    catch e
        if isa(e, MATLAB.MEngineError)
            println("\n ERROR: MATLAB engine not available")
            println("Solutions:")
            println("1. Ensure MATLAB is installed and licensed")
            println("2. Run 'matlab -regserver' in Command Prompt as Administrator")
            println("3. Restart Julia")
            return false
        else
            println("\n ERROR: $(e)")
            return false
        end
    end
end


# Run example only when file is executed directly (not when included)
# NOTE: This auto-execution is disabled when used in pipeline scripts
if !@isdefined(__CLAMP_SOLVER_ALREADY_LOADED__) && abspath(PROGRAM_FILE) == @__FILE__
    # Define a flag to indicate we've loaded this module
    global __CLAMP_SOLVER_ALREADY_LOADED__ = true
    
    println(" Starting Clamp Fixed Rod Solver...\n")
    println(" File executed: $(basename(@__FILE__))")
    
    # Setup project environment (only when run directly)
    project_root = setup_project_environment(activate_env = true, instantiate = false)
    println("🔧 Project environment activated: $project_root")

    # You can run with default config or create a custom one:
    # Default config:
    #success = clamp_fixed_rod_solver()

    # Or with custom config (example):
    println("⚙️  Using custom example configuration ")
    custom_config = create_config(xp = 0.8, yp = 0.0)
    success = clamp_fixed_rod_solver(custom_config)

    println()  # Empty line for better readability

    if success
        println("✓ Solver completed successfully!")
    else
        println("✗ Solver encountered errors!")
    end
    
# If you want to see when the module is loaded silently, uncomment the next 3 lines:
# else
#     println(" Module loaded: clamp_fixed_rod_solver function available")
#     println(" (Script execution skipped - use solve_and_prepare_data.jl for custom configs)")
end
````
</attachment>

</attachments>
<prompt>
What about standalone mode and module mode?
</prompt>
~~~



## Response
### Assistant
~~~md
## Standalone Mode vs Module Mode in `clamp_fixed_rod_solver.jl`

### Overview
The solver is designed to work in two distinct modes:

1. **Standalone Mode**: When run directly as a script
2. **Module Mode**: When included/imported by other scripts

### Mode Detection Mechanism

````julia
# Mode detection logic at the end of the file
if !@isdefined(__CLAMP_SOLVER_ALREADY_LOADED__) && abspath(PROGRAM_FILE) == @__FILE__
    # STANDALONE MODE
    global __CLAMP_SOLVER_ALREADY_LOADED__ = true
    # ... execution code ...
else
    # MODULE MODE (silent loading)
end
````

### Standalone Mode

**When activated**: Running directly from command line or REPL
```bash
julia clamp_fixed_rod_solver.jl
```

**What happens**:
1. Sets up project environment
2. Activates Julia environment
3. Runs example with custom configuration
4. Prints detailed output and status

**Key features**:
````julia
# Setup project environment (only when run directly)
project_root = setup_project_environment(activate_env = true, instantiate = false)
println("🔧 Project environment activated: $project_root")

# Run with example configuration
custom_config = create_config(xp = 0.8, yp = 0.0)
success = clamp_fixed_rod_solver(custom_config)
````

### Module Mode

**When activated**: Including from another script
```julia
include("src/solvers/clamp_fixed_rod_solver.jl")
```

**What happens**:
1. Loads function definitions silently
2. Makes `clamp_fixed_rod_solver()` available
3. No automatic execution
4. No environment activation

**Usage example**:
````julia
# In another script (e.g., solve_and_prepare_data.jl)
include("../utils/project_utils.jl")
include("../utils/config.jl")
include("../solvers/clamp_fixed_rod_solver.jl")

# Now use the function
config = create_config(xp = 0.5, mode = 3.0)
success = clamp_fixed_rod_solver(config)
````

### Key Differences

| Aspect | Standalone Mode | Module Mode |
|--------|----------------|-------------|
| **Environment Setup** | Automatic | Manual (by calling script) |
| **Execution** | Runs example automatically | No automatic execution |
| **Output** | Verbose with status messages | Silent loading |
| **Configuration** | Uses hardcoded example | Fully customizable |
| **Use Case** | Quick testing/demo | Part of larger workflow |

### Conditional Includes

The file handles dependencies intelligently:

````julia
# Setup for standalone usage (when run directly)
if !@isdefined(ClampedRodConfig)
    include("../utils/project_utils.jl")
    include("../utils/config.jl")
end
````

This ensures:
- **Standalone**: Loads required dependencies
- **Module**: Assumes dependencies already loaded (avoids duplicates)

### Benefits of This Design

1. **Flexibility**: Same code works in multiple contexts
2. **Testing**: Easy to test solver independently
3. **Integration**: Clean integration into pipelines
4. **No Duplication**: Avoids redefining functions/types
5. **Clear Separation**: Execution logic separated from function definitions

### Practical Examples

**Standalone Usage** (for testing):
```bash
# Quick test with default parameters
julia src/solvers/clamp_fixed_rod_solver.jl
```

**Module Usage** (in pipeline):
```julia
# In a batch processing script
configs = [
    create_config(xp = 0.2, mode = 2.0),
    create_config(xp = 0.5, mode = 2.0),
    create_config(xp = 0.8, mode = 3.0)
]

for config in configs
    success = clamp_fixed_rod_solver(config)
    println("Config xp=$(config.xp): $(success ? "✓" : "✗")")
end
```

### Guard Variable

The `__CLAMP_SOLVER_ALREADY_LOADED__` guard prevents:
- Multiple executions when included multiple times
- Conflicts in complex include hierarchies
- Unintended re-runs of example code

This dual-mode design makes the solver both user-friendly for quick tests and professional for integration into larger systems.
~~~


<style>
[id^="system"], [id^="user"], [id^="assistant"] {
		margin: 4px 0 4px 0;
}

.markdown-body > pre {
		padding: 4px 16px;
}
</style>
